// simulate admixture with recorded ancestry
initialize() {
    initializeSLiMModelType("nonWF");
    initializeTreeSeq();
    initializeMutationRate(1e-7);
    initializeRecombinationRate(1e-8);
    initializeMutationType("m1", 0.5, "f", 0.0);
    initializeGenomicElementType("g1", m1, 1.0);
    initializeGenomicElement(g1, 0, 1e7 - 1);

    defineConstant("NUM_POPS", 4);
    defineConstant("GENS", 10);
    defineConstant("N", 1000); // individuals per pop

    defineConstant("ASSORT", matrix(c(
        0.7, 0.1, 0.1, 0.1,
        0.1, 0.7, 0.1, 0.1,
        0.1, 0.1, 0.7, 0.1,
        0.1, 0.1, 0.1, 0.7
    ), nrow=NUM_POPS, byrow=T));
}

1 early() {
    for (i in 0:(NUM_POPS - 1)) {
        sim.addSubpop(i, N);
    }
}

1 late() {
    // tag each founder individual with ancestry vector
    for (pop in sim.subpopulations) {
        for (ind in pop.individuals) {
            ancestry = rep(0.0, NUM_POPS);
            ancestry[pop.id] = 1.0;
            ind.setValue("ancestry", ancestry);
        }
    }
}

// Reproduction logic
2:GENS late() {
    sim.treeSeqRememberIndividuals(sim.subpopulations.individuals);

    // Collect all individuals to remove
    inds_to_kill = sim.subpopulations.individuals;
    sim.killIndividuals(inds_to_kill);  // SLiM 5.0 compatible

    // Reproduce into the same subpopulation
    for (i in 0:(NUM_POPS - 1)) {
        for (j in 1:N) {
            parent1s = sim.subpopulations[i].sampleIndividuals(1, replace=T);
            
            if (size(parent1s) > 0) {
                parent1 = parent1s[0];

                probs = ASSORT[i, ];
                mate_pop = sample(sim.subpopulations, 1, weights=probs);
                parent2s = mate_pop.sampleIndividuals(1, replace=T);

                if (size(parent2s) > 0) {
                    parent2 = parent2s[0];
                    offspring = sim.subpopulations[i].addCrossed(parent1, parent2);
                    anc1 = parent1.getValue("ancestry");
                    anc2 = parent2.getValue("ancestry");
                    new_anc = (anc1 + anc2) / 2.0;
                    offspring.setValue("ancestry", new_anc);
                }
            }
        }
    }
}

late() {
    sim.treeSeqRememberIndividuals(sim.subpopulations.individuals);
    sim.treeSeqOutput("multi_gen_admixture_output.trees");
}